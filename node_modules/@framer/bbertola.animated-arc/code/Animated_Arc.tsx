import * as React from "react"
import { PropertyControls, addPropertyControls, ControlType, motion, motionValue } from "framer"

export function Animated_Arc({
    width,
    height,
    length,
    strokeWidth,
    lineCap,
    color,
    colorEnd,
    angle,
    animateFrom,
    animateTo,
    duration,
    delay,
    animationType,
    damping,
    mass,
    stiffness,
    easeCurve,
    endCap
}) {
    let anglePI = angle * (Math.PI / 180)
    let currentAngle = {
        x1: Math.round(50 + Math.sin(anglePI) * 50),
        y1: Math.round(50 + Math.cos(anglePI) * 50),
        x2: Math.round(50 + Math.sin(anglePI + Math.PI) * 50),
        y2: Math.round(50 + Math.cos(anglePI + Math.PI) * 50),
    }

    const endPercentage = (animateTo / 360) * 100

    const rotate = motionValue(animateFrom)
    const [revolve, updateRevolve] = React.useState(animateFrom)

    React.useEffect(
        () =>
            rotate.onChange(latest => {
                //console.log(latest)
                if (Math.round(latest) <= 359.999999) {
                    console.log(Math.round(latest))
                    updateRevolve(latest)
                }
            }),
        []
    )
    //const endPercentage = (dummyRotate.get() / 360) * 100
    return (
        <div style={{ position: "relative", width: width, height: height }}>
        <motion.div
                    style={{
                        rotate,
                    }}
                    initial={{ rotate: animateFrom, opacity: 0 }}
                    key={"cool"}
                    animate={{ rotate: animateTo }}
                    transition={{
                        delay: delay,
                        type: animationType,
                        damping: damping,
                        mass: mass,
                        stiffness: stiffness,
                        ease: easeCurve,
                        duration: duration,
                    }}
                ></motion.div>
            <svg
                width={width}
                height={height}
                viewBox={`0 0 ${width} ${height}`}
                style={{ position: "absolute", top: 0, left: 0}}
            >

                <path
                    d={arc(
                        width / 2,
                        height / 2,
                        width / 2 - strokeWidth / 2,
                        0,
                        revolve
                    )}
                    fill={"none"}
                    stroke={colorEnd}
                    strokeWidth={strokeWidth}
                    strokeLinecap={endCap}

                />
            </svg>
            <svg
                width={width}
                height={height}
                viewBox={`0 0 ${width} ${height}`}
                style={{
                    WebkitMask: `conic-gradient(rgba(0, 0, 0, 1.0) 0%, rgba(0, 0, 0,0.0) ${endPercentage}%)`,
                   // boxShadow: "0px 2px 5px 10px rgba(0, 0, 0, 0.25)",
                    //WebkitFilter: 'drop-shadow(0px 2px 5px 10px rgba(0, 0, 0, 0.25))',
                }}
            >
{/* <defs xmlns="http://www.w3.org/2000/svg">
    <filter id="dropshadow" height="200%" width="200%" top="0px" left="0">
      <feGaussianBlur in="SourceAlpha" stdDeviation="3"/> 
      <feOffset dx="2" dy="2" result="offsetblur"/> 
      <feMerge> 
        <feMergeNode/>
        <feMergeNode in="SourceGraphic"/> 
      </feMerge>
    </filter>
  </defs> */}
                <path
                    d={arc(
                        width / 2,
                        height / 2,
                        width / 2 - strokeWidth / 2,
                        0,
                        revolve
                    )}
                    
                    fill={"none"}
                    stroke={color}
                    strokeWidth={strokeWidth}
                    strokeLinecap={endCap}
                   //filter={"url(#dropshadow)"}
                />
            </svg>
            <div
                style={{
                    position: "absolute",
                    width: strokeWidth / 2,
                    height: strokeWidth,
                    background: "transparent",
                    top: `calc(50% - ${width / 2}px)`,
                    left: `calc(50% - ${strokeWidth / 2}px)`,
                    overflow: "hidden"
                   // boxShadow: "0px 2px 5px 10px rgba(0, 0, 0, 0.25)"
                }}
            >
                <div
                    style={{
                        width: strokeWidth,
                        height: strokeWidth,
                        background: color,
                        borderRadius: endCap == "round" ? strokeWidth / 2 : 0,
                       // WebkitFilter: 'drop-shadow(0px 2px 5px 10px rgba(0, 0, 0, 0.25))',
                        
                      //  boxShadow: "0px 2px 5px 10px rgba(0, 0, 0, 0.25)"
                    }}
                />
            </div>
        </div>
    )
}

Animated_Arc.defaultProps = {
    length: 360,
    strokeWidth: 60,
    lineCap: true,
    color: "#0EF",
    colorEnd: "#60F",
    angle: 180,
}

addPropertyControls(Animated_Arc, {
    strokeWidth: {
        type: ControlType.Number,
        title: "Stroke",
        min: 0,
        //max: 200,
    },
    color: {
        type: ControlType.Color,
        title: "Front",
    },
    colorEnd: {
        type: ControlType.Color,
        title: "Back",
    },
    endCap: {
        type: ControlType.Enum,
        optionTitles: ["Round", "Square"],
        options: ["round", "square"],
        defaultValue: "round"
    },
    animateFrom: {
        type: ControlType.Number,
        title: "From",
        min: 0,
        max: 360
    },
    animateTo: {
        type: ControlType.Number,
        title: "To",
        min: 0,
        max: 360,
    },
    delay: {
        type: ControlType.Number,
        unit: "s",
        step: 0.05,
        displayStepper: true,
        title: "Delay Start",
        defaultValue: 0,
        min: 0,
    },
    animationType: {
        type: ControlType.SegmentedEnum,
        options: ["spring", "tween"],
        title: "Animation",
        defaultValue: "spring",
    },
    damping: {
        type: ControlType.Number,
        min: 0,
        step: 1,
        title: "↳ Damping",
        defaultValue: 10,
        hidden: props => {
            return props.animationType == "tween"
        },
    },
    mass: {
        type: ControlType.Number,
        min: 0,
        title: "↳ Mass",
        defaultValue: 1,
        hidden: props => {
            return props.animationType == "tween"
        },
    },
    stiffness: {
        type: ControlType.Number,
        min: 0,
        step: 1,
        title: "↳ Stiffness",
        defaultValue: 100,
        hidden: props => {
            return props.animationType == "tween"
        },
    },
    duration: {
        type: ControlType.Number,
        unit: "s",
        step: 0.05,
        displayStepper: true,
        title: "↳ Duration",
        defaultValue: 0.3,
        min: 0,
        hidden: props => {
            return props.animationType == "spring"
        },
    },
    easeCurve: {
        type: ControlType.Enum,
        options: [
            "linear",
            "easeIn",
            "easeOut",
            "easeInOut",
            "circIn",
            "circOut",
            "circInOut",
            "backIn",
            "backOut",
            "backInOut",
            "anticipate",
        ],
        title: "↳ Ease Curve",
        defaultValue: "easeInOut",
        hidden: props => {
            return props.animationType == "spring"
        },
    },
})

const angleInRadians = angleInDegrees =>
    (angleInDegrees - 90) * (Math.PI / 180.0)

const polarToCartesian = (centerX, centerY, radius, angleInDegrees) => {
    const a = angleInRadians(angleInDegrees)
    return {
        x: centerX + radius * Math.cos(a),
        y: centerY + radius * Math.sin(a),
    }
}

const arc = (x, y, radius, startAngle, endAngle) => {
    const fullCircle = endAngle - startAngle === 360
    const start = polarToCartesian(x, y, radius, endAngle - 0.01)
    const end = polarToCartesian(x, y, radius, startAngle)
    const arcFlag = endAngle - startAngle <= 180 ? "0" : "1"

    let d = [
        "M",
        start.x,
        start.y,
        "A",
        radius,
        radius,
        0,
        arcFlag,
        0,
        end.x,
        end.y,
    ].join(" ")

    if (fullCircle) d += "z"
    return d
}
